---
const nodes = [
  { id: 'music', label: 'Music', x: 280, y: 210, group: 'core' },
  { id: 'visual', label: 'Visual', x: 540, y: 180, group: 'core' },
  { id: 'video', label: 'Video', x: 690, y: 330, group: 'core' },
  { id: 'newark', label: 'Newark', x: 420, y: 410, group: 'place' },
  { id: 'scraps', label: 'Scraps', x: 220, y: 410, group: 'archive' },
  { id: 'writing', label: 'Writing', x: 505, y: 300, group: 'archive' },
  { id: 'tools', label: 'Tools', x: 360, y: 140, group: 'lab' }
];

const edges = [
  ['music', 'visual'],
  ['music', 'scraps'],
  ['visual', 'video'],
  ['newark', 'visual'],
  ['newark', 'writing'],
  ['scraps', 'writing'],
  ['tools', 'music'],
  ['tools', 'visual'],
  ['video', 'writing']
];
---

<section class="rounded-2xl border border-zinc-300 bg-white/70 p-4 dark:border-zinc-700 dark:bg-zinc-900/60">
  <div class="mb-3 flex items-center justify-between gap-3">
    <p class="text-sm text-zinc-600 dark:text-zinc-300">Drag to pan · Scroll to zoom · Click node to focus · Double-click node to expand neighbors.</p>
    <button id="reset-map" class="rounded border border-zinc-400 px-3 py-1 text-sm hover:border-accent dark:border-zinc-600">Reset view</button>
  </div>

  <div class="map-wrap relative h-[500px] overflow-hidden rounded-xl border border-zinc-300 bg-paper dark:border-zinc-700 dark:bg-zinc-950" tabindex="0" aria-label="Interactive neural map">
    <svg id="neural-svg" viewBox="0 0 960 540" class="h-full w-full">
      <g id="viewport">
        <g id="edge-layer">
          {edges.map(([fromId, toId]) => {
            const from = nodes.find((node) => node.id === fromId);
            const to = nodes.find((node) => node.id === toId);
            if (!from || !to) return null;
            return <line data-edge={`${fromId}-${toId}`} x1={from.x} y1={from.y} x2={to.x} y2={to.y} class="stroke-zinc-400 dark:stroke-zinc-600" stroke-width="2" />;
          })}
        </g>
        <g id="node-layer">
          {nodes.map((node) => (
            <g data-node={node.id} class="node cursor-pointer">
              <circle cx={node.x} cy={node.y} r="28" class="fill-white stroke-zinc-500 dark:fill-zinc-900 dark:stroke-zinc-300" stroke-width="2" />
              <text x={node.x} y={node.y + 5} text-anchor="middle" class="pointer-events-none fill-zinc-900 text-[13px] dark:fill-zinc-100">{node.label}</text>
            </g>
          ))}
        </g>
      </g>
    </svg>
  </div>
</section>

<script is:inline define:vars={{ nodes, edges }}>
  const wrap = document.querySelector('.map-wrap');
  const viewport = document.getElementById('viewport');
  const resetBtn = document.getElementById('reset-map');
  const nodeEls = document.querySelectorAll('[data-node]');
  const edgeEls = document.querySelectorAll('[data-edge]');

  let tx = 0;
  let ty = 0;
  let scale = 1;
  let dragging = false;
  let startX = 0;
  let startY = 0;

  const linksByNode = new Map();
  edges.forEach(([a, b]) => {
    linksByNode.set(a, [...(linksByNode.get(a) || []), b]);
    linksByNode.set(b, [...(linksByNode.get(b) || []), a]);
  });

  const render = () => {
    viewport?.setAttribute('transform', `translate(${tx} ${ty}) scale(${scale})`);
  };

  const clearHighlight = () => {
    nodeEls.forEach((el) => {
      el.querySelector('circle')?.setAttribute('class', 'fill-white stroke-zinc-500 dark:fill-zinc-900 dark:stroke-zinc-300');
    });
    edgeEls.forEach((el) => {
      el.setAttribute('class', 'stroke-zinc-400 dark:stroke-zinc-600');
      el.setAttribute('stroke-width', '2');
    });
  };

  const highlight = (focusId, expand = false) => {
    clearHighlight();
    const neighbors = new Set([focusId, ...(linksByNode.get(focusId) || [])]);

    nodeEls.forEach((el) => {
      const id = el.getAttribute('data-node');
      const circle = el.querySelector('circle');
      if (!circle) return;
      if (id === focusId) {
        circle.setAttribute('class', 'fill-accent/10 stroke-accent dark:fill-accent/20 dark:stroke-orange-300');
        circle.setAttribute('r', expand ? '34' : '30');
      } else if (expand && neighbors.has(id)) {
        circle.setAttribute('class', 'fill-zinc-200 stroke-zinc-700 dark:fill-zinc-700 dark:stroke-zinc-100');
      } else {
        circle.setAttribute('class', 'fill-zinc-100 stroke-zinc-400 dark:fill-zinc-900 dark:stroke-zinc-700');
        circle.setAttribute('r', '28');
      }
    });

    edgeEls.forEach((el) => {
      const [a, b] = (el.getAttribute('data-edge') || '').split('-');
      const isLinked = a === focusId || b === focusId || (expand && neighbors.has(a) && neighbors.has(b));
      if (isLinked) {
        el.setAttribute('class', 'stroke-accent dark:stroke-orange-300');
        el.setAttribute('stroke-width', expand ? '3' : '2.5');
      } else {
        el.setAttribute('class', 'stroke-zinc-300 dark:stroke-zinc-700');
        el.setAttribute('stroke-width', '1.5');
      }
    });
  };

  wrap?.addEventListener('pointerdown', (event) => {
    dragging = true;
    startX = event.clientX - tx;
    startY = event.clientY - ty;
    wrap.setPointerCapture(event.pointerId);
  });

  wrap?.addEventListener('pointermove', (event) => {
    if (!dragging) return;
    tx = event.clientX - startX;
    ty = event.clientY - startY;
    render();
  });

  wrap?.addEventListener('pointerup', () => {
    dragging = false;
  });

  wrap?.addEventListener('wheel', (event) => {
    event.preventDefault();
    const next = scale - event.deltaY * 0.001;
    scale = Math.min(2.25, Math.max(0.65, next));
    render();
  }, { passive: false });

  nodeEls.forEach((el) => {
    el.addEventListener('click', () => {
      const id = el.getAttribute('data-node');
      if (id) highlight(id, false);
    });
    el.addEventListener('dblclick', () => {
      const id = el.getAttribute('data-node');
      if (id) highlight(id, true);
    });
  });

  resetBtn?.addEventListener('click', () => {
    tx = 0;
    ty = 0;
    scale = 1;
    render();
    clearHighlight();
  });

  render();
</script>
